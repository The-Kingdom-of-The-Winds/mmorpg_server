defmodule TCPProtocol.Crypt do
  @moduledoc """
  Provides all necessary encryption/decryption functionality for sending and receiving frames from the client.
  All encryption is symmetrical and reversable, so the identical functions handle encryption and decryption.
  There are two types of xor-based encryption schemes used depending on frame type, static key and stream key.

  This code is based on the mithia server decryption code (albeit much cleaner, documented, and in elixir). Big
  shoutout to whoever reverse engineered it all together, figured out the magic values, etc. You're insane.

  ## Static Key
  The static key cipher is only used for a few of the frame types, and is based around a permanent static key,
  and the sequence number, which is an incrementing unsigned short at the 5th byte of every frame.

  To encrypt/unencrypt the binary data-
  1.  The data is xor'ed with the 9-byte static key. If the data is longer than the key, the key is repeated
  2.  The data is xor'ed with the sequence number of the frame
  3.  The data is broken up into groups of 9 bytes. Each group of 9 bytes is xor'ed with the group number (i.e,
      the first 9 bytes are xor'ed with 0x0, second 9 bytes xor'ed with 0x1, etc)
  3a. If the group number is the same as the sequence of the frame, the group xor is not applied, as this would
      undo the sequence xor
  3b. The group number is reset to 0 every 255 groups (hence the group % 255 on line 46)
  4.  Tada, you are done

  ## Stream Key
  The stream key cipher is used for most of the frames and builds ontop of the static key method, but uses a
  randomly generated unique key for every frame. The key is derived from a shared secret (the character name,
  in the exact case entered by the user) and the last 3 bytes of the frame (the initialization value or "iv").

  The iv is made up of two values, one byte (iv1) and one short (iv2).

  ### Stream IV
  For encrypting from the server -> client, the iv1 is generated by taking a random number between 100-254 and
  xor'ing it with 0x21. The iv2 is generated by taking a random number between 256-65532 and xor'ing it with
  0x7424.

  For decrypting from the client -> server, the iv is taken from the last 3 bytes of the frame.
  For example, assuming the last 3 bytes are [0x10, 0x20, 0x30]

  iv1 is the middle byte, 0x20, then xor'ed with 0x25
  iv2 is the first and last byte, combined into a short, and flip-flopped, 0x3010, then xor'ed with 0x2361

  ### Key table
  Once the iv values are generated, we then generate a table of bytes from the character name. The key table
  only needs to be generated once per-session.

  To generate the key table:

  1. Take the character name and md5() the value. Take the bytes as a hex string
  2. Take these hashed bytes and md5() them again [i.e, md5(md5(name))]
  3. Hash the hashes bytes again append this hash to the hash from step 2 [i.e, md5(md5(name)) + md5(md5(md5(name)))]
  4. Repeat steps 3 until you have a table of 1024 characters (i.e, 32 times)

  Note- it is important that you hash the lowcase string representation of the hash, not the raw bytes.

  ### Stream key
  Lastly, we use the iv and key table to derive a per-frame 9 byte key that is used as the key value for static_key/3

  To derive the stream key:

  1.  Raise iv1 to the power of 2
  2.  Generate a table index by taking iv1 * byte index + iv2.
  2a. Wrap the value if it's >= 1024 (hence the &&& 0x03FF- same as modulo division)
  3.  Take the character at the table index
  4.  Increment iv1 by 3
  5.  Repeat until you have 9 bytes, this is your stream key

  Once you have a stream key, you can decrypt/encrypt the frame by using the value as the key in the static key cipher
  discussed above.
  """

  require Logger

  use Bitwise

  @doc """
  Decrypts/encrypts binary frame data with provided static key. If no static key is provided, uses the default
  key. Returns the decrypted/unencrypted data as binary data.
  """
  def static_key(<<data::binary>>, seq), do: static_key_fast(data, seq, "KEYKEYKEY")
  def static_key(<<data::binary>>, seq, key), do: static_key_fast(data, seq, key)

  def static_key(data, seq, key) when is_list(data) and is_list(key) do
    key_len = length(key)

    Enum.with_index(data)
    |> Enum.map(fn {byte, i} ->
      xor_byte = byte ^^^ Enum.at(key, rem(i, key_len))
      group = div(i, 9)

      case group do
        ^seq -> xor_byte ^^^ seq
        _ -> xor_byte ^^^ rem(group, 255) ^^^ seq
      end
    end)
    |> :binary.list_to_bin()
  end

  def static_key_fast(<<data::binary>>, seq, <<key::72>>) do
    chunk_seq =
      seq <<< 72 ||| seq <<< 64 ||| seq <<< 56 ||| seq <<< 48 ||| seq <<< 40 ||| seq <<< 32 ||| seq <<< 24 |||
        seq <<< 16 ||| seq <<< 8 ||| seq

    seq_xor_key = chunk_seq ^^^ key

    static_key_fast(data, seq_xor_key, seq, 0, []) |> Enum.reverse() |> IO.iodata_to_binary()
  end

  def static_key_fast(<<data::72, rest::binary>>, seq_key, seq, group_num, encrypted) do
    encrypted_chunk = crypt_chunk(<<data::72>>, seq_key, seq, group_num)
    static_key_fast(<<rest::binary>>, seq_key, seq, group_num + 1, [encrypted_chunk | encrypted])
  end

  def static_key_fast(last_chunk, seq_key, seq, group_num, encrypted) do
    chunk_size = byte_size(last_chunk)
    pad = (9 - chunk_size) * 8

    <<padded_chunk::binary>> = <<last_chunk::binary, 0::size(pad)>>

    <<encrypted_chunk::size(chunk_size)-bytes, _::size(pad)>> =
      crypt_chunk(<<padded_chunk::binary>>, seq_key, seq, group_num)

    [encrypted_chunk | encrypted]
  end

  defp crypt_chunk(<<data::72>>, seq_key, seq, group_num) do
    chunk_xor = data ^^^ seq_key
    group_xor = 0x010101010101010101 * rem(group_num, 255)

    encrypted =
      case group_num do
        ^seq -> chunk_xor
        _ -> chunk_xor ^^^ group_xor
      end

    <<encrypted::72>>
  end

  # Maybe this is faster???
  # defp test(data, seq, key) do
  #   key = to_char_list(key)
  #   size = byte_size(data)
  #   pad = 9 - rem(size, 9)
  #   byte_size = size * 8
  #   <<as_int::size(byte_size)-integer>> = data
  #   shifted = as_int <<< pad
  #   shifted_size = (size + pad) * 8
  #   binary_again = <<shifted::size(shifted_size)>>

  #   groups = div(byte_size(binary_again), 9) - 1

  #   seqb = <<seq, seq, seq, seq, seq, seq, seq, seq, seq>>
  #   kk = :crypto.exor(seqb, key)

  #   full_key =
  #     Enum.map(0..groups, fn
  #       ^seq ->
  #         kk

  #       i ->
  #         gp = rem(i, 255)
  #         :crypto.exor(<<gp, gp, gp, gp, gp, gp, gp, gp, gp>>, kk)
  #     end)

  #   key = :crypto.exor(binary_again, full_key)
  #   <<int_ag::size(shifted_size)-integer>> = key
  #   sh = int_ag >>> pad
  #   <<sh::size(byte_size)>>
  # end

  @doc """
  Decrypts/encrypts binary frame data with a per-stream key from the shared secret (character name) and iv.
  If iv value is nil, a fresh iv is generated.
  If iv value is :trailer, the iv will be derived from the frame trailer

  Returns a tuple of the decrypted/encrypted binary frame data and the iv used
  """
  def stream_key(<<data::binary>>, seq, secret, :trailer) do
    iv = derive_iv_from_trailer(data)
    stream_key(data, seq, secret, iv)
  end

  def stream_key(<<data::binary>>, seq, secret, nil) do
    iv = derive_iv_from_rand()
    <<stream_key(data, seq, secret, iv)::binary, encode_iv(iv)::binary>>
  end

  def stream_key(<<data::binary>>, seq, secret, iv) do
    stream_key = derive_stream_key(secret, iv)
    static_key(data, seq, stream_key)
  end

  @doc """
  Derives the stream key from the shared secret and iv. Uses an ets table to cache md5 hash chain, which saves us about
  100 microseconds per frame.
  """
  def derive_stream_key(secret, {iv1, iv2}) do
    key = hash_chain(secret)
    iv1 = iv1 * iv1

    {stream_key, _} =
      Enum.map_reduce(0..8, iv1, fn idx, acc ->
        pos = acc * idx + iv2 &&& 0x03FF

        # Previously, this was Enum.at(pos, key) but in theory this saves us a conversion to char_list and malloc
        <<_::size(pos)-bytes, data::8, _::binary>> = key
        {data, acc + 3}
      end)

    stream_key |> IO.iodata_to_binary()
  end

  # Try to look up the precomputed hash chain in our ets table cache first.
  defp hash_chain(secret) do
    case :ets.lookup(:client_key_cache, secret) do
      [{_, key}] -> key
      _ -> hash_chain(secret, :no_cache)
    end
  end

  defp hash_chain(secret, :no_cache) do
    chain_iv =
      :crypto.hash(:md5, secret)
      |> Base.encode16(case: :lower)

    # The initial value to generate the chain is the hashed chain_iv (so, md5(md5(secret))). The reason it
    # does not use chain_iv directly for hash_chain/1 is because chain_iv doesn't end up as part of the accumulator
    key =
      :crypto.hash(:md5, chain_iv)
      |> Base.encode16(case: :lower)
      |> do_hash_chain(32)
      |> IO.iodata_to_binary()

    :ets.insert(:client_key_cache, {secret, key})

    key
  end

  # Hash the accumulator, append the hashed value onto the accumulator and recurse until we have 1024 bytes of key
  # material. Weirdly, must hash the lowercase hex string encoded value between iterations, not the raw bytes
  defp do_hash_chain(acc, count) when count >= 0 do
    hash =
      :crypto.hash(:md5, acc)
      |> Base.encode16(case: :lower)

    do_hash_chain([acc, hash], count - 1)
  end

  defp do_hash_chain(hash, _), do: hash

  @doc """
  Derives the iv from the 3 bytes in the frame trailer. Used for decrypting frames from the client.
  Returns a tuple of the two iv values
  """
  def derive_iv_from_trailer(<<a::8, b::8, c::8>>) do
    # Two initialization values are derived from the last 3 bytes of the frame, which are used to generate the
    # decryption key from the shared secret (md5 of character name). To get the first iv, just take the middle byte
    # and xor it with the magic value (0x25). For the second iv, combine the LSB and MSB into a short and xor it with
    # the magic value (0x2361)

    iv_1 = b ^^^ 0x25
    iv_2 = ((c <<< 8) + a) ^^^ 0x2361

    {iv_1, iv_2}
  end

  def derive_iv_from_trailer(<<data::binary>>) do
    # Get the trailer (last 3 bytes) of the frame.
    frame_len = byte_size(data) - 3
    <<_::size(frame_len)-bytes, trailer::24>> = data

    derive_iv_from_trailer(<<trailer::24>>)
  end

  @doc """
  Generates new random iv values for encryption. Used for encrypting frames to the client.
  Returns a tuple of the two iv values
  """
  def derive_iv_from_rand() do
    # Generate random initialization values for encrypting frames to the client, with specific ranges. I have no
    # idea if the ranges matter to the client or if the client depends on the randomness as some sort of nonce.
    # The ranges are as follows:
    # >= 100 iv_1 <= 254
    # >= 256 iv_2 <= 65532

    iv_1 = :rand.uniform(154) + 100
    iv_2 = :rand.uniform(65276) + 256

    {iv_1, iv_2}
  end

  @doc """
  Encryptes the IV to be sent back to client by xoring them with some magic bytes (0x21 and 0x7424)
  """
  def encode_iv({iv_1, iv_2}) do
    <<a::8, b::8>> = <<iv_2 ^^^ 0x7424::16>>
    iv_1 = iv_1 ^^^ 0x21

    <<b::8, iv_1::8, a::8>>
  end
end
